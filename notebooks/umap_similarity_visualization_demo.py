# -*- coding: utf-8 -*-
"""UMAP Similarity Visualization Demo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hV3FDwT5YE1J0WjJhJ0M1IAHkGOP9BFI
"""

# Import necessary libraries
!pip install -q sentence-transformers matplotlib scikit-learn umap-learn

from sentence_transformers import SentenceTransformer
import umap
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

strings = strings = [
    # Technology
    "Artificial Intelligence", "Machine Learning", "Deep Learning", "Neural Networks",
    "Computer Vision", "Natural Language Processing", "Data Science", "Robotics",
    "Internet of Things", "Blockchain",

    # Healthcare
    "Cardiovascular Health", "Oncology", "Immunotherapy", "Radiology", "Telemedicine",
    "Genetics", "Mental Health", "Pediatrics", "Epidemiology", "Nutrition",

    # Finance
    "Stock Market", "Cryptocurrency", "Investment Banking", "Financial Planning",
    "Portfolio Management", "Insurance", "Venture Capital", "Wealth Management",
    "Economic Policy", "Asset Allocation",

    # Education
    "Online Learning", "Educational Technology", "Curriculum Development",
    "Higher Education", "Student Engagement", "Special Education", "Teacher Training",
    "Distance Education", "Learning Analytics", "Academic Research",

    # Environment
    "Climate Change", "Renewable Energy", "Conservation", "Biodiversity",
    "Carbon Footprint", "Sustainable Agriculture", "Ocean Pollution", "Wildlife Protection",
    "Deforestation", "Recycling",

    # Entertainment
    "Streaming Services", "Cinematography", "Video Games", "Stand-Up Comedy",
    "Live Concerts", "Music Production", "Film Festivals", "Reality TV", "Celebrity Gossip",
    "Animation",

    # Sports
    "Soccer", "Basketball", "Tennis", "Swimming", "Gymnastics", "Track and Field",
    "Martial Arts", "Winter Sports", "Baseball", "Cricket",

    # Travel
    "Adventure Tourism", "Cultural Heritage Sites", "Road Trips", "Backpacking",
    "Eco-tourism", "Luxury Resorts", "Cruise Travel", "Airline Industry",
    "Camping", "Travel Photography",

    # Food & Beverage
    "Organic Farming", "Plant-Based Diet", "Fast Food", "Fine Dining",
    "Wine Tasting", "Culinary Arts", "Street Food", "Coffee Culture",
    "Pastry Making", "Home Brewing",

    # Science & Space
    "Astronomy", "Particle Physics", "Quantum Mechanics", "Space Exploration",
    "Astrobiology", "Meteorology", "Geology", "Oceanography",
    "Paleontology", "Scientific Research"
]


# Step 1: Convert strings to embeddings
# Load a pre-trained sentence transformer model
model = SentenceTransformer('all-MiniLM-L6-v2')  # Efficient model for embeddings

# Encode strings into embeddings
embeddings = model.encode(strings)

# Step 2: Use UMAP to reduce dimensions to 3D
umap_reducer = umap.UMAP(n_components=3, random_state=42)
embeddings_3d = umap_reducer.fit_transform(embeddings)

# Step 3: Define colors for each category (10 categories)
colors = [
    "red", "blue", "green", "purple", "orange",
    "brown", "pink", "gray", "olive", "cyan"
]

# Assign each string a color based on its category
color_assignments = [colors[i // 10] for i in range(100)]

# Step 4: Plot in 3D
fig = plt.figure(figsize=(10, 7))
ax = fig.add_subplot(111, projection='3d')

# Plot each point with a smaller size and category-based color
for i, label in enumerate(strings):
    x, y, z = embeddings_3d[i]
    ax.scatter(x, y, z, color=color_assignments[i], s=20)  # s=20 makes points smaller
    ax.text(x, y, z, label, color=color_assignments[i], fontsize=8)

# Set labels for axes
ax.set_xlabel("X Dimension")
ax.set_ylabel("Y Dimension")
ax.set_zlabel("Z Dimension")
plt.title("3D Visualization of String Embeddings with UMAP and Category Colors")
plt.show()

# Step 2: Use UMAP to reduce dimensions to 2D
umap_reducer = umap.UMAP(n_components=2, random_state=42)
embeddings_2d = umap_reducer.fit_transform(embeddings)

# Step 3: Define colors for each category (10 categories)
colors = [
    "red", "blue", "green", "purple", "orange",
    "brown", "pink", "gray", "olive", "cyan"
]

# Assign each string a color based on its category
color_assignments = [colors[i // 10] for i in range(100)]

# Step 4: Plot in 2D
plt.figure(figsize=(10, 7))

# Plot each point with a smaller size and category-based color
for i, label in enumerate(strings):
    x, y = embeddings_2d[i]
    plt.scatter(x, y, color=color_assignments[i], s=20)  # s=20 makes points smaller
    plt.text(x, y, label, color=color_assignments[i], fontsize=8)

# Set labels for axes
plt.xlabel("X Dimension")
plt.ylabel("Y Dimension")
plt.title("2D Visualization of String Embeddings with UMAP and Category Colors")
plt.show()

import json

# Step 1: Load the list of strings (names) from the JSON file
with open('/content/names_output.json', 'r') as file:
    strings = json.load(file)

# Step 2: Convert strings to embeddings
# Load a pre-trained sentence transformer model
model = SentenceTransformer('all-MiniLM-L6-v2')

# Encode strings into embeddings
embeddings = model.encode(strings)

# Step 3: Use UMAP to reduce dimensions to 2D
umap_reducer = umap.UMAP(n_components=2, random_state=42)
embeddings_2d = umap_reducer.fit_transform(embeddings)

# Step 4: Scale the 2D embeddings to spread points more widely
scale_factor = 100  # Adjust this factor to control spread
embeddings_2d_scaled = embeddings_2d * scale_factor

# Step 6: Plot in 2D with adjusted plot limits for more space
plt.figure(figsize=(10, 7))

# Plot each point with a smaller size and category-based color
for i, label in enumerate(strings):
    x, y = embeddings_2d_scaled[i]
    plt.scatter(x, y, s=20)  # s=20 makes points smaller
    plt.text(x, y, label, fontsize=3)

# Set labels for axes
plt.xlabel("X Dimension")
plt.ylabel("Y Dimension")
plt.title("2D Visualization of Extracted Names with UMAP and Category Colors")

# Show the plot
plt.show()

!pip install plotly

import json
import plotly.graph_objects as go
import matplotlib.colors as mcolors
from sentence_transformers import SentenceTransformer
import umap

# Function to recursively extract names and assign colors based on hierarchy
def extract_and_plot_hierarchy(names_nested, embeddings, depth=0, parent_color=None, parent_category=None):
    base_size = 15  # starting point size for first-level names
    size_decay = 3  # amount the size decays for each deeper level

    x_coords = []  # To store x coordinates for each point
    y_coords = []  # To store y coordinates for each point
    text_labels = []  # Text labels for points (names)
    point_sizes = []  # Point sizes based on depth
    point_colors = []  # Point colors based on hierarchy
    category_colors = {}  # Dictionary to store unique colors for top-level categories

    # Define a color map using matplotlib to generate a series of colors
    color_map = list(mcolors.TABLEAU_COLORS.values())

    if parent_category not in category_colors:
        # Assign a new color for the parent category (top-level name)
        category_colors[parent_category] = color_map[len(category_colors) % len(color_map)]

    current_color = category_colors[parent_category]
    point_size = base_size - size_decay * depth  # Decrease size as depth increases

    if point_size < 3:
        point_size = 3  # Avoid extremely small points

    # Recursively process each nested list and extract names
    for i, item in enumerate(names_nested):
        if isinstance(item, list):
            # This represents a deeper level in the hierarchy
            sub_x, sub_y, sub_text, sub_sizes, sub_colors = extract_and_plot_hierarchy(
                item, embeddings, depth + 1, parent_color=current_color, parent_category=parent_category
            )
            x_coords.extend(sub_x)
            y_coords.extend(sub_y)
            text_labels.extend(sub_text)
            point_sizes.extend(sub_sizes)
            point_colors.extend(sub_colors)
        else:
            # This is a name at the current level
            x_coords.append(embeddings[i, 0])  # Use the first embedding dimension for x
            y_coords.append(embeddings[i, 1])  # Use the second embedding dimension for y

            text_labels.append(item)
            point_sizes.append(point_size)
            point_colors.append(current_color)

    return x_coords, y_coords, text_labels, point_sizes, point_colors


# Load the names_nested (previously generated list of lists)
with open('/content/names_nested.json', 'r') as file:
    names_nested = json.load(file)

# Step 1: Flatten the names into a list for embeddings
names_flat = []

def flatten_names(names):
    for item in names:
        if isinstance(item, list):
            flatten_names(item)
        else:
            names_flat.append(item)

flatten_names(names_nested)

# Step 2: Generate embeddings for all names using SentenceTransformer
model = SentenceTransformer('all-MiniLM-L6-v2')
embeddings = model.encode(names_flat)

# Step 3: Reduce dimensions using UMAP (2D)
umap_reducer = umap.UMAP(n_components=2, random_state=42)
embeddings_2d = umap_reducer.fit_transform(embeddings)

# Step 4: Scale the 2D embeddings
scale_factor = 50
embeddings_2d_scaled = embeddings_2d * scale_factor

# Step 5: Create the plot using Plotly with hierarchical colors and sizes
x, y, labels, sizes, colors = extract_and_plot_hierarchy(names_nested, embeddings_2d_scaled)

# Create the interactive plot with Plotly
fig = go.Figure()

# Add scatter points for each name
fig.add_trace(go.Scatter(
    x=x,
    y=y,
    mode='markers+text',
    text=labels,
    textposition='top center',
    marker=dict(size=sizes, color=colors, opacity=0.7),
))

# Update layout for better visualization
fig.update_layout(
    title="Hierarchical Visualization of Names with Embeddings and UMAP",
    xaxis_title="X Dimension",
    yaxis_title="Y Dimension",
    showlegend=False,
    hovermode="closest",
    autosize=True
)

# Show the interactive plot
fig.show()